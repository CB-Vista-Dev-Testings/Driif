name: Covrr Web App 

on:
  push:
    branches: [ main, develop ]

env:
  # Update these values with your actual information
  HARBOR_URL: 74.4560.19.03    # Your Harbor instance URL
  HARBOR_PROJECT: driif  # Your private project name in Harbor
  IMAGE_NAME: covrr-webapp             # Name for your Docker image
  K8S_NAMESPACE: driif-dev       # Kubernetes namespace
  K8S_DEPLOYMENT_NAME: covrr-webapp           # Kubernetes deployment name

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Generate image tag
      id: tag
      run: |
        BRANCH=${GITHUB_REF#refs/heads/}
        COMMIT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        
        # Use branch name in tag for better tracking
        if [ "$BRANCH" = "main" ]; then
          VERSION_TAG="latest"
        else
          VERSION_TAG="${BRANCH}"
        fi
        
        # Create both a latest/branch tag and a unique SHA tag
        echo "VERSION_TAG=${VERSION_TAG}" >> $GITHUB_ENV
        echo "SHA_TAG=${COMMIT_SHA}" >> $GITHUB_ENV
        echo "FULL_IMAGE_PATH=${{ env.HARBOR_URL }}/${{ env.HARBOR_PROJECT }}/${{ env.IMAGE_NAME }}" >> $GITHUB_ENV
    
    # Web app build process - uncomment and adjust based on your stack
    # - name: Setup Node.js
    #   uses: actions/setup-node@v4
    #   with:
    #     node-version: '20'
    #     cache: 'npm'
    #     
    # - name: Install dependencies
    #   run: npm ci
    #     
    # - name: Run tests
    #   run: npm test
    #     
    # - name: Build web app
    #   run: npm run build
    
    - name: Login to Harbor
      uses: docker/login-action@v3
      with:
        registry: ${{ env.HARBOR_URL }}
        username: ${{ secrets.HARBOR_USERNAME }}
        password: ${{ secrets.HARBOR_PASSWORD }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ env.FULL_IMAGE_PATH }}:${{ env.VERSION_TAG }}
          ${{ env.FULL_IMAGE_PATH }}:${{ env.SHA_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-to-civo-k8s:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
    - name: Set image tag
      run: |
        BRANCH=${GITHUB_REF#refs/heads/}
        COMMIT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        
        if [ "$BRANCH" = "main" ]; then
          VERSION_TAG="latest"
        else
          VERSION_TAG="${BRANCH}"
        fi
        
        # Using the SHA tag for deployments ensures we track exact versions
        echo "SHA_TAG=${COMMIT_SHA}" >> $GITHUB_ENV
        echo "FULL_IMAGE_PATH=${{ env.HARBOR_URL }}/${{ env.HARBOR_PROJECT }}/${{ env.IMAGE_NAME }}:${COMMIT_SHA}" >> $GITHUB_ENV
    
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Setup CIVO kubectl configuration
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.CIVO_KUBECONFIG }}" > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
        kubectl config use-context civo
    
    - name: Check if namespace exists
      run: |
        if ! kubectl get namespace ${{ env.K8S_NAMESPACE }} &> /dev/null; then
          kubectl create namespace ${{ env.K8S_NAMESPACE }}
          echo "Created namespace ${{ env.K8S_NAMESPACE }}"
        fi
    
    - name: Ensure Harbor registry secret exists
      run: |
        kubectl get secret harbor-registry-secret -n ${{ env.K8S_NAMESPACE }} || \
        kubectl create secret docker-registry harbor-registry-secret \
          --docker-server=${{ env.HARBOR_URL }} \
          --docker-username=${{ secrets.HARBOR_USERNAME }} \
          --docker-password=${{ secrets.HARBOR_PASSWORD }} \
          --namespace=${{ env.K8S_NAMESPACE }}
    
    - name: Deploy or update application
      run: |
        # Check if deployment exists
        if kubectl get deployment ${{ env.K8S_DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }} &> /dev/null; then
          # Update existing deployment with new image
          kubectl set image deployment/${{ env.K8S_DEPLOYMENT_NAME }} \
            ${{ env.K8S_DEPLOYMENT_NAME }}=${{ env.FULL_IMAGE_PATH }} \
            -n ${{ env.K8S_NAMESPACE }}
        else
          # Create deployment if it doesn't exist
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.K8S_DEPLOYMENT_NAME }}
            namespace: ${{ env.K8S_NAMESPACE }}
            labels:
              app: ${{ env.K8S_DEPLOYMENT_NAME }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.K8S_DEPLOYMENT_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.K8S_DEPLOYMENT_NAME }}
              spec:
                containers:
                - name: ${{ env.K8S_DEPLOYMENT_NAME }}
                  image: ${{ env.FULL_IMAGE_PATH }}
                  ports:
                  - containerPort: 80
                  resources:
                    limits:
                      cpu: "0.5"
                      memory: "512Mi"
                    requests:
                      cpu: "0.2"
                      memory: "256Mi"
                  imagePullPolicy: Always
                imagePullSecrets:
                - name: harbor-registry-secret
          EOF

          # Create service if it doesn't exist
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.K8S_DEPLOYMENT_NAME }}-service
            namespace: ${{ env.K8S_NAMESPACE }}
          spec:
            selector:
              app: ${{ env.K8S_DEPLOYMENT_NAME }}
            ports:
            - port: 80
              targetPort: 80
            type: ClusterIP
          EOF
        fi
    
    - name: Verify deployment rollout
      run: |
        kubectl rollout status deployment/${{ env.K8S_DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=180s